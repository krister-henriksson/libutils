

//
//  WARNING!!! BUGGY CLASS AND METHODS!!!
//


#ifndef UTILS_MATRIX_CHOLESKYDECOMP_HPP
#define UTILS_MATRIX_CHOLESKYDECOMP_HPP



#include <iostream>
#include <string>
#include <sstream>

#include <cstdlib>

#include "utils.hpp"
#include "utils-math.hpp"
#include "utils-vector.hpp"
#include "utils-matrix.hpp"



namespace utils {


  /* #########################################################################
     Class to store the Cholesky decomposition of a given matrix.
     #########################################################################
  */


  template <typename T>
  class Choleskydecomp {

  private:
    int n;
    Matrix<T> el;

  public:

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // Construct and store L in L * L^T = A.
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Choleskydecomp(Matrix<T> & A, int & status)
      : n(A.nrows()), el(A) 
    {
      int i,j,k;
      T sum;
      
      status=0;
      if (el.ncols() != el.nrows()){
	std::cout << "Cannot construct Cholesky decomposition of non-square matrix. Exiting." << std::endl;
	exit(EXIT_FAILURE);
      }



      /*
	T sum2;

      for (i=0; i!=n; ++i)
	for (j=0; j!=n; ++j)
	  el.elem(i,j)=0;

      std::cout << "Made it here 1  n: " << n << std::endl;

      for (k=0; k!=n; ++k){

	sum = A.elem(k,k);
	for (i=0; i<=k-1; ++i){
	  std::cout << "Made it here 2   i k: " << i << " " << k << std::endl;
	  sum -= el.elem(i,k) * el.elem(i,k);
	}
	std::cout << "Made it here 2.1" << std::endl;

	if (sum>0.0){
	  el.elem(k,k) = sqrt(sum);
	  std::cout << "Made it here 2.2" << std::endl;

	  if (k+1<=n){
	    for (j=k; j<n; ++j){
	      std::cout << "Made it here 3   k j: " << k << " " << j << std::endl;

	      sum2 = 0.0;
	      for (i=0; i<=k-1; ++i){
		std::cout << "Made it here 3   k j i: " << k << " " << j << " " << i << std::endl;
		sum2 += el.elem(i,j) * el.elem(i,k);
	      }
	      
	      el.elem(k,j) = (A.elem(k,j) - sum2)/el.elem(k,k);
	    }
	  }
	}
	else {
	  std::cout << "Cholesky decomposition failed." << std::endl;
	}

      }

      el = el.transpose();

      std::cout << "el :" << std::endl;
      std::cout << el << std::endl;
      std::cout << "el * el^T - A:" << std::endl;
      std::cout << el * el.transpose() - A << std::endl;
*/


      
      for (i=0; i!=n; ++i){
	for (j=i; j!=n; ++j){
	  sum=el.elem(i,j);
	  for (k=i-1; k>=0; --k)
	    sum -= el.elem(i,k) * el.elem(j,k);
	  if (i==j){
	    if (sum <= 0){
	      std::cout << "Cholesky decomposition failed." << std::endl;
	      status=1;
	      return;
	    }
	    el.elem(i,i) = sqrt(sum);
	  }
	  else
	    el.elem(j,i) = sum/el.elem(i,i);
	}
      }
      
      for (i=0; i!=n; ++i) for (j=0; j!=i; ++j) el.elem(j,i)=0;



    }






    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // Solve A * x = b.
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    void solve(Vector<T> & b, Vector<T> & x){
      int i,k;
      T sum;

      x.resize(b.size());

      if (b.size() != n || x.size() != n){
	std::cout << "Bad sizes of vectors in Cholesky solver. Exiting." << std::endl;
	exit(EXIT_FAILURE);
      }

      // Solve L * y = b, storing y in x.
      for (i=0; i!=n; ++i){
	sum = b[i];
	for (k=i-1; k>=0; --k) sum -= el.elem(i,k) * x[k];
	x[i] = sum/el.elem(i,i);
      }

      // Solve L^T * x = y.
      for (i=n-1; i>=0; --i){
	sum=x[i];
	for (k=i+1; k<n; ++k) sum -= el.elem(k,i)*x[k];
	x[i] = sum/el.elem(i,i);
      }
    }


    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // Calculate L * y = b.
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    void elmult(Vector<T> & y, Vector<T> & b){
      int i,j;
      if (b.size() != n || y.size() != n){
	std::cout << "Bad sizes of vectors in Cholesky solver. Exiting." << std::endl;
	exit(EXIT_FAILURE);
      }
      for (i=0; i!=n; ++i){
	b[i]=0;
	for (j=0; j!=i; ++j) b[i] += el.elem(i,j) * y[j];
      }
    }


    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // Solve L * y = b.
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    void elsolve(Vector<T> & b, Vector<T> & y){
      int i,j;
      T sum=0;
      
      if (b.size() != n || y.size() != n){
	std::cout << "Bad sizes of vectors in Cholesky solver. Exiting." << std::endl;
	exit(EXIT_FAILURE);
      }
      for (i=0; i!=n; ++i){
	sum=b[i];
	for (j=0; j!=i; ++j) sum -= el.elem(i,j)*y[j];
	  y[i] = sum/el.elem(i,i);
      }
    }
    

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // Calculate the inverse.
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    
    void inverse(Matrix<T> & A_inv){
      int i,j,k;
      T sum;
      
      A_inv.resize(n,n);
      for (i=0; i!=n; ++i)
	for (j=0; j!=i; ++j) {
	  sum = (i==j ? 1 : 0);
	  for (k=i-1; k!=j; --k)
	    sum -= el.elem(i,k)*A_inv.elem(j,k);
	  A_inv.elem(j,i) = sum / el.elem(i,i);
	}
      for (i=n-1; i>=0; --i)
	for (j=0; j!=i; ++j){
	  sum = (i<j ? 0 : A_inv.elem(j,i) );
	  for (k=i+1; k!=n; ++k)
	    sum -= el.elem(k,i) * A_inv.elem(j,k);
	  A_inv.elem(i,j) = A_inv.elem(j,i) = sum / el.elem(i,i);
	}
    }


    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    
    // Calculate the log. of the determinant.
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    T logdet(){
      T sum=0;
      
      for (int i=0; i!=n; ++i) sum += log(el.elem(i,i));
      return 2*sum;
    }
    
  } ;

}





#endif

