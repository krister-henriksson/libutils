



// Calculate Cartesian distance vector. Obey periodics, with the cell
// extending between -0.5 * box and 0.5 * box by default. If lowlim>0
// then a distance of 1.0 * box is added to the calculated values to make
// them be between 0 and box.
void AtomSystem::get_atom_distance_vec(const Vector<double> & r1,
				       const Vector<double> & r2,
				       Vector<double> & v,
				       const double lowlim) const {
  double d0,d1,d2;
 
  v[0] = r1[0] - r2[0];
  v[1] = r1[1] - r2[1];
  v[2] = r1[2] - r2[2];

  // Get distance in skew coordinate system, where periodics can be checked:
  d0 = v[0];
  d1 = v[1];
  d2 = v[2];
  if (! isCart){
    d0 = Bravaismatrix_inv.elem(0,0) * v[0]
      + Bravaismatrix_inv.elem(0,1) * v[1]
      + Bravaismatrix_inv.elem(0,2) * v[2];
    d1 = Bravaismatrix_inv.elem(1,0) * v[0]
      + Bravaismatrix_inv.elem(1,1) * v[1]
      + Bravaismatrix_inv.elem(1,2) * v[2];
    d2 = Bravaismatrix_inv.elem(2,0) * v[0]
      + Bravaismatrix_inv.elem(2,1) * v[1]
      + Bravaismatrix_inv.elem(2,2) * v[2];
  }

  // Periodics check:
  double pf1=-0.5, pf2=0.5;
  if (lowlim>0){ pf1 = 0.0; pf2 = 1.0; }

  while (pbc[0] && d0 <  pf1 * boxlen[0]) d0 += boxlen[0];
  while (pbc[0] && d0 >= pf2 * boxlen[0]) d0 -= boxlen[0];
  while (pbc[1] && d1 <  pf1 * boxlen[1]) d1 += boxlen[1];
  while (pbc[1] && d1 >= pf2 * boxlen[1]) d1 -= boxlen[1];
  while (pbc[2] && d2 <  pf1 * boxlen[2]) d2 += boxlen[2];
  while (pbc[2] && d2 >= pf2 * boxlen[2]) d2 -= boxlen[2];



    
  // Get distance in Cartesian coordinate system:
  v[0] = d0;
  v[1] = d1;
  v[2] = d2;
  if (! isCart){
    v[0] = boxdir.elem(0,0) * d0 + boxdir.elem(0,1) * d1 + boxdir.elem(0,2) * d2;
    v[1] = boxdir.elem(1,0) * d0 + boxdir.elem(1,1) * d1 + boxdir.elem(1,2) * d2;
    v[2] = boxdir.elem(2,0) * d0 + boxdir.elem(2,1) * d1 + boxdir.elem(2,2) * d2;
  }
}


// ##############################################################################################



// Get the skew coordinates when Cartesian coordinates are known.
void AtomSystem::get_coords_cart2skew(const Vector<double> & drc,
				      Vector<double> & v,
				      const double lowlim) const {

  // Get distance in skew coordinate system, where periodics can be checked:
  v[0] = drc[0];
  v[1] = drc[1];
  v[2] = drc[2];
  if (! isCart){
    v[0] = Bravaismatrix_inv.elem(0,0) * drc[0]
      + Bravaismatrix_inv.elem(0,1) * drc[1]
      + Bravaismatrix_inv.elem(0,2) * drc[2];
    v[1] = Bravaismatrix_inv.elem(1,0) * drc[0]
      + Bravaismatrix_inv.elem(1,1) * drc[1]
      + Bravaismatrix_inv.elem(1,2) * drc[2];
    v[2] = Bravaismatrix_inv.elem(2,0) * drc[0]
      + Bravaismatrix_inv.elem(2,1) * drc[1]
      + Bravaismatrix_inv.elem(2,2) * drc[2];
  }

  // Periodics check:
  double pf1=-0.5, pf2=0.5;
  if (lowlim>0){ pf1 = 0.0; pf2 = 1.0; }
  while (pbc[0] && v[0] <  pf1 * boxlen[0]) v[0] += boxlen[0];
  while (pbc[0] && v[0] >= pf2 * boxlen[0]) v[0] -= boxlen[0];
  while (pbc[1] && v[1] <  pf1 * boxlen[1]) v[1] += boxlen[1];
  while (pbc[1] && v[1] >= pf2 * boxlen[1]) v[1] -= boxlen[1];
  while (pbc[2] && v[2] <  pf1 * boxlen[2]) v[2] += boxlen[2];
  while (pbc[2] && v[2] >= pf2 * boxlen[2]) v[2] -= boxlen[2];
}


// ##############################################################################################


// Get the Cartesian coordinates when skew coordinates are known.
void AtomSystem::get_coords_skew2cart(Vector<double> & drs,
				      Vector<double> & v,
				      const double lowlim) const {
  // Periodics check:
  double pf1=-0.5, pf2=0.5;
  if (lowlim>0){ pf1 = 0.0; pf2 = 1.0; }

  while (pbc[0] && drs[0] <  pf1 * boxlen[0]) drs[0] += boxlen[0];
  while (pbc[0] && drs[0] >= pf2 * boxlen[0]) drs[0] -= boxlen[0];
  while (pbc[1] && drs[1] <  pf1 * boxlen[1]) drs[1] += boxlen[1];
  while (pbc[1] && drs[1] >= pf2 * boxlen[1]) drs[1] -= boxlen[1];
  while (pbc[2] && drs[2] <  pf1 * boxlen[2]) drs[2] += boxlen[2];
  while (pbc[2] && drs[2] >= pf2 * boxlen[2]) drs[2] -= boxlen[2];

  // Get distance in Cartesian coordinate system:
  v[0] = drs[0];
  v[1] = drs[1];
  v[2] = drs[2];
  if (! isCart){
    v[0] = boxdir.elem(0,0) * drs[0] + boxdir.elem(0,1) * drs[1] + boxdir.elem(0,2) * drs[2];
    v[1] = boxdir.elem(1,0) * drs[0] + boxdir.elem(1,1) * drs[1] + boxdir.elem(1,2) * drs[2];
    v[2] = boxdir.elem(2,0) * drs[0] + boxdir.elem(2,1) * drs[1] + boxdir.elem(2,2) * drs[2];
  }
}



// ##############################################################################################


/*
  rxyz = (x,y,z) becomes transported by amount
  - f1 in direction a = boxdir.col(0)
  - f2 in direction b = boxdir.col(0)
  - f3 in direction c = boxdir.col(0)
*/
void AtomSystem::translate_cartpos_in_skewspace(Vector<double> & pos,
						double f1,
						double f2,
						double f3){
  Vector<double> d;

  // Get coordinates in skew coordinate system:
  d = pos;
  if (! isCart)
    d = Bravaismatrix_inv * pos;

  d[0] += f1;
  d[1] += f2;
  d[2] += f3;

  // Get coordinates in Cartesian coordinate system:
  pos = d;
  if (! isCart)
    pos = boxdir * d;
}


