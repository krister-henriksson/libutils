



// Set box direction vectors and length of box in the specified direction. The vectors
// are normalized inside the method.
// NOTE: The box direction vectors are stored column-wise in the mboxdir matrix.
void AtomSystem::set_boxdir(const int idir,
			    const double & px,
			    const double & py,
			    const double & pz
			    ){
  if (boxdir.nrows()<3 || boxdir.ncols()<3) boxdir.resize(3,3);
  if (idir<0 || idir>=3){
    cout << "Index " << idir << " is out of range. Allowed: 0 to 2." << endl;
    exit(EXIT_FAILURE);
  }

  Vector<double> tmpv(3,0.0);
  tmpv[0]=px;
  tmpv[1]=py;
  tmpv[2]=pz;
  tmpv.normalize();
  boxdir.col(idir, tmpv);
}


void AtomSystem::set_boxdir(const int idir, Vector<double> & p){

  if (boxdir.nrows()<3 || boxdir.ncols()<3) boxdir.resize(3,3);
  if (idir<0 || idir>=3){
    cout << "Index " << idir << " is out of range. Allowed: 0 to 2." << endl;
    exit(EXIT_FAILURE);
  }

  p.normalize();
  boxdir.col(idir, p);
}



// Get box direction vectors:
void AtomSystem::get_boxdir(const int idir,
			    Vector<double> & v) const {
  if (boxdir.nrows()<3 || boxdir.ncols()<3){
    cout << "Box has not been set yet. Exiting." << endl;
    exit(EXIT_FAILURE);
  }
  if (idir<0 || idir>=3){
    cout << "Index " << idir << " is out of range. Allowed: 0 to 2." << endl;
    exit(EXIT_FAILURE);
  }
  v = boxdir.col(idir);
}



// Normalize the box direction vectors and build the Bravais matrix and its inverse:
void AtomSystem::update_box_geometry(){
  Vector<double> tmpv(3,0);

  // Normalize:
  tmpv = boxdir.col(0);  tmpv.normalize();  boxdir.col(0, tmpv);
  tmpv = boxdir.col(1);  tmpv.normalize();  boxdir.col(1, tmpv);
  tmpv = boxdir.col(2);  tmpv.normalize();  boxdir.col(2, tmpv);


  // Calculate the Bravaismatrix:
  /* The mboxdir matrix --- with the box direction vectors stored as columns ---
     is actually the Bravais matrix. We need to keep it up to date and also
     its inverse.
  */

  
  /*
  rvec = x xhat + y yhat + z zhat
       = A ahat + B bhat + C chat

       x = rvec * xhat = A ahat * xhat + B bhat * xhat + C chat * xhat
       y = rvec * yhat = A ahat * yhat + B bhat * yhat + C chat * yhat
       z = rvec * zhat = A ahat * zhat + B bhat * zhat + C chat * zhat

       <=>

      | x |   | ahat * xhat   bhat * xhat   chat * xhat |   | A |
      | y | = | ahat * yhat   bhat * yhat   chat * yhat | * | B |
      | z |   | ahat * zhat   bhat * zhat   chat * zhat |   | C |

       <=>

       rvec_xyz = BM      * rvec_abc
       rvec_abc = BM^(-1) * rvec_xyz

       To get coordinates in xyz space multiply coordinates in abc space by BM.
       To get coordinates in abc space multiply coordinates in xyz space by BM^(-1).
  */

  isCart = false;
  double td0,td1,td2, eps = numeric_limits<double>::epsilon();;
  int k=0;

  // boxdir(0)
  td0 = boxdir.col(0)[0]; if (td0<0) td0 *= -1;
  td1 = boxdir.col(0)[1]; if (td1<0) td1 *= -1;
  td2 = boxdir.col(0)[2]; if (td2<0) td2 *= -1;
  if (td1<eps && td2<eps) ++k;
  // boxdir(1)
  td0 = boxdir.col(1)[0]; if (td0<0) td0 *= -1;
  td1 = boxdir.col(1)[1]; if (td1<0) td1 *= -1;
  td2 = boxdir.col(1)[2]; if (td2<0) td2 *= -1;
  if (td0<eps && td2<eps) ++k;
  // boxdir(2)
  td0 = boxdir.col(2)[0]; if (td0<0) td0 *= -1;
  td1 = boxdir.col(2)[1]; if (td1<0) td1 *= -1;
  td2 = boxdir.col(2)[2]; if (td2<0) td2 *= -1;
  if (td0<eps && td1<eps) ++k;

  if (k == 3) isCart = true;


  /*
  LUdecomp<double> lud ( boxdir );
  lud.inverse(  Bravaismatrix_inv );
  */
  if (! isCart)
    boxdir.inverse( Bravaismatrix_inv );
  else {
    Bravaismatrix_inv.elem(0,0) = 1.0;
    Bravaismatrix_inv.elem(1,0) = 0.0;
    Bravaismatrix_inv.elem(2,0) = 0.0;

    Bravaismatrix_inv.elem(0,1) = 0.0;
    Bravaismatrix_inv.elem(1,1) = 1.0;
    Bravaismatrix_inv.elem(2,1) = 0.0;

    Bravaismatrix_inv.elem(0,2) = 0.0;
    Bravaismatrix_inv.elem(1,2) = 0.0;
    Bravaismatrix_inv.elem(2,2) = 1.0;
  }


  /*
  cout << "Bravaismatrix:" << endl;
  cout << mboxdir << endl;

  cout << "Bravaismatrix_inverse:" << endl;
  cout << mBravaismatrix_inv << endl;
  */
}


