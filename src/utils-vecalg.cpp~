

#include <cmath>



#include "utils-linalg.hpp"
#include "utils-errors.hpp"


using utils::aborterror;



// #####################################################################
// Get rotation matrices
// #####################################################################
void utils::get_rotation_matrix(Matrix<double> & R,
				const double & th,
				const int axis
				){
  if (R.ncols()!=3 && R.nrows()!=3) R.resize(3,3);
  for (int i=0; i<3; ++i) for (int j=0; j<3; ++j) R.elem(i,j)=0.0;
    
  double c = cos(th);
  double s = sin(th);

  if (axis==0){
    R.elem(0,0) = 1;
    R.elem(0,1) = 0;
    R.elem(0,2) = 0;

    R.elem(1,0) = 0;
    R.elem(1,1) = c;
    R.elem(1,2) = -s;

    R.elem(2,0) = 0;
    R.elem(2,1) = s;
    R.elem(2,2) = c;
  }
  else if (axis==1){
    R.elem(0,0) = c;
    R.elem(0,1) = 0;
    R.elem(0,2) = s;
  
    R.elem(1,0) = 0;
    R.elem(1,1) = 1;
    R.elem(1,2) = 0;
  
    R.elem(2,0) = -s;
    R.elem(2,1) = 0;
    R.elem(2,2) = c;
  }
  else {
    R.elem(0,0) = c;
    R.elem(0,1) = -s;
    R.elem(0,2) = 0;
  
    R.elem(1,0) = s;
    R.elem(1,1) = c;
    R.elem(1,2) = 0;
  
    R.elem(2,0) = 0;
    R.elem(2,1) = 0;
    R.elem(2,2) = 1;
  }

  return;
}

void utils::get_improper_rotation_matrix(Matrix<double> & R,
					 const double & th,
					 const int axis
					 ){
  Matrix<double> I(3,3,0), IR(3,3,0);
  I.elem(0,0) = I.elem(1,1) = I.elem(2,2) = -1.0;

  utils::get_rotation_matrix(R, th, axis);
  IR = I * R;
  R = IR;
}



void utils::get_reflection_matrix(Matrix<double> & R,
				  const int axis
				  ){
  if (R.ncols()!=3 && R.nrows()!=3) R.resize(3,3);
  for (int i=0; i<3; ++i) for (int j=0; j<3; ++j) R.elem(i,j)=0.0;

  if (axis==0){
    R.elem(0,0) = -1;
    R.elem(0,1) = 0;
    R.elem(0,2) = 0;

    R.elem(1,0) = 0;
    R.elem(1,1) = 1;
    R.elem(1,2) = 0;

    R.elem(2,0) = 0;
    R.elem(2,1) = 0;
    R.elem(2,2) = 1;
  }
  else if (axis==1){
    R.elem(0,0) = 1;
    R.elem(0,1) = 0;
    R.elem(0,2) = 0;

    R.elem(1,0) = 0;
    R.elem(1,1) = -1;
    R.elem(1,2) = 0;

    R.elem(2,0) = 0;
    R.elem(2,1) = 0;
    R.elem(2,2) = 1;
  }
  else {
    R.elem(0,0) = 1;
    R.elem(0,1) = 0;
    R.elem(0,2) = 0;

    R.elem(1,0) = 0;
    R.elem(1,1) = 1;
    R.elem(1,2) = 0;

    R.elem(2,0) = 0;
    R.elem(2,1) = 0;
    R.elem(2,2) = -1;
  }

  return;
}






void utils::get_rotation_matrix_u(Matrix<double> & R,
				  const Vector<double> & u,
				  const double & th
				  ){
  if (R.ncols()!=3 && R.nrows()!=3) R.resize(3,3);
  for (int i=0; i<3; ++i) for (int j=0; j<3; ++j) R.elem(i,j)=0.0;

  if (u.size()!=3) aborterror("ERROR: get_rotation_matrix vector u does not contain 3 elements!");

  Vector<double> n = u;
  n.normalize();

  double c = cos(th);
  double s = sin(th);
  double nx = n[0];
  double ny = n[1];
  double nz = n[2];

  R.elem(0,0) = c+nx*nx*(1-c);
  R.elem(0,1) = nx*ny*(1-c)-nz*s;
  R.elem(0,2) = nx*nz*(1-c)+ny*s;
  
  R.elem(1,0) = ny*nx*(1-c)+nz*s;
  R.elem(1,1) = c + ny*ny*(1-c);
  R.elem(1,2) = ny*nz*(1-c)-nx*s;
  
  R.elem(2,0) = nz*nx*(1-c)-ny*s;
  R.elem(2,1) = nz*ny*(1-c)+nx*s;
  R.elem(2,2) = c+nz*nz*(1-c);
  

  Matrix<double> K(3,3,0), K2(3,3,0), I(3,3,0);
  K.elem(0,0) =  0.0;
  K.elem(0,1) = -nz;
  K.elem(0,2) =  ny;
  K.elem(1,0) =  nz;
  K.elem(1,1) =  0.0;
  K.elem(1,2) = -nx;
  K.elem(2,0) = -ny;
  K.elem(2,1) =  nx;
  K.elem(2,2) =  0.0;
  K2 = K * K;
  I.elem(0,0) = I.elem(1,1) = I.elem(2,2) = 1.0;


  R = I + s * K + (1.0 - c) * K2;
  Vector<double> tmp(3,0); tmp[0]=tmp[1]=tmp[2]=0.5;
  //cout << "Rotation matrix times (0.5, 0.5, 0.5) = " << R * tmp << endl;

  return;
}




void utils::get_improper_rotation_matrix_u(Matrix<double> & R,
					   const Vector<double> & u,
					   const double & th
					   ){

  Matrix<double> I(3,3,0), IR(3,3,0);
  I.elem(0,0) = I.elem(1,1) = I.elem(2,2) = -1.0;

  utils::get_rotation_matrix_u(R, u, th);
  IR = I * R;
  R = IR;

  return;
}



/*
  Rotate vector 'vec' around an axis with direction 'axis'. The vector
  starts at a point 'vec_point' and the axis goes through a point
  'axis_point'.
 */

void utils::rotate_around_axis(const Vector<double> & axis,
			       const Vector<double> & OA, // axis_point
			       const Vector<double> & vec,
			       const Vector<double> & OP, // vec_point
			       const double & th,
			       Vector<double> & vec_rot,
			       Vector<double> & vec_point_rot
			       ){
  /*

    Vector from origin to axis_point is OA.
    Vector from origin to vec_point is OV.
    OV point projected onto axis is OQ.




    Vector v to be rotated starts at point p. The vector from the origin
    to the end point of vector v is is p+v.
    Axis direction vector n going through point u.
    Vector w starts at point u and ends at p+v, w = p+v-u := v+s

    1. Translate to origin o: w => w' = w-u, s => s' = s-u
    2. Rotate: w'_rot, s'_rot
    3. Translate back: w_rot = w'_rot+u, s_rot = s'_rot+u

    v_rot = w_rot - s_rot = w'_rot - s'_rot
   */

  Vector<double> OA_OP(3,0), OQ(3,0);
  Vector<double> nvec(axis), dvec(3,0), tvec(3,0);
  Matrix<double> R(3,3,0);
  Vector<double> tvec_rot(3,0);


  nvec.normalize();
  get_rotation_matrix_u(R, nvec, th);

  // Rotate vector:
  vec_rot  = R * vec;

  OA_OP = OP - OA;
  // Projection onto axis:
  dvec = scalarproduct( OA_OP, nvec ) * nvec;
  tvec = OA_OP - dvec;
  
  OQ = OA + dvec;

  // Rotate vector:
  tvec_rot = R * tvec;
  vec_point_rot = OQ + tvec_rot;


  /*
  // Get vector from point on rotation axis to point where vector to be rotated starts:
  OAP_OVP = OVP - OAP;
  // Vector from point on rotation axis to the end of vector to be rotated:
  OAP_V   = vec + OAP_OVP;
  // Axis and vector to be rotated now pass through the same point.

  // Translate axis and vector to be rotated to the origin:
  OAP_OVP = OAP_OVP - OAP;
  OAP_V   = OAP_V   - OAP;

  // Get rotation matrix:
  get_rotation_matrix_u(R, axis, th);
  // Rotate vectors:
  OAP_OVP_rot = R * OAP_OVP;
  OAP_V_rot   = R * OAP_V;

  // Translate axis and vector back:
  OAP_OVP_rot = OAP_OVP_rot + OAP;
  OAP_V_rot   = OAP_V_rot   + OAP;

  // Starting point of rotated vector is now at:
  vec_point_rot = OAP_OVP_rot;
  // The vector we are interested in is the vector difference:
  vec_rot       = OAP_V_rot - OAP_OVP_rot;




  OAP_OVP = OVP - OAP;
  xvec = scalarproduct( OAP_OVP, nvec ) * nvec;
  tvec = OVP_OAP - xvec;

  */

  
  return;
}


